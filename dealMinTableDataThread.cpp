#include "dealMinTableDataThread.h"
#include <qdatetime.h>

#include "SQLFuncPublic.h"


DealMinTableDataThread::DealMinTableDataThread()
{
	m_bPause = false;
	m_iCommitedLine = 0 ;
	m_iCommitedSize = 0 ; 
}

DealMinTableDataThread::~DealMinTableDataThread()
{

}

void DealMinTableDataThread::stop()
{

}

void DealMinTableDataThread::run()
{ 
	SQLWCHAR * sErrorMsg = NULL; 

	//任务开始
	m_sMsg = CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode("第[%1]进程已启动，准备连接数据库[%2]")
		.arg(m_iProcessID)
		.arg(CGlobalDataSaver::GetInstance()->m_sDbService);
	CGlobalDataSaver::GetInstance()->PrintMsg(m_sMsg);

	SQLHENV henv;
	SQLHDBC hdbc_dre;
	SQLHSTMT hstmt_dre;
	SQLRETURN rc;
	//申请ODBC环境、连接及SQL句柄并设置
	rc = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv);
	if (!SQL_SUCCEEDED(rc)) 
	{
		m_sMsg = CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode("第[%1]进程申请ODBC环境、连接及SQL句柄出错，错误码[%2]，进程将退出")
			.arg(m_iProcessID)
			.arg(rc);
		CGlobalDataSaver::GetInstance()->PrintMsg(m_sMsg);
		m_iJobflag = RunState::except;
		return ;
	}

	rc = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER) (SQL_OV_ODBC3), SQL_IS_UINTEGER);
	if (!SQL_SUCCEEDED(rc)) 
	{
		m_sMsg = CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode("第[%1]进程SQLSetEnvAttr出错，错误码[%2]，进程将退出")
			.arg(m_iProcessID)
			.arg(rc);
		CGlobalDataSaver::GetInstance()->PrintMsg(m_sMsg);
		m_iJobflag = RunState::except;
		SQLFreeHandle(SQL_HANDLE_ENV, henv);
		return ;
	}

	rc = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc_dre); 
	if (!SQL_SUCCEEDED(rc))  
	{
		m_sMsg = CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode("第[%1]进程SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc_dre)出错，错误码[%2]，进程将退出")
			.arg(m_iProcessID)
			.arg(rc);
		CGlobalDataSaver::GetInstance()->PrintMsg(m_sMsg);
		m_iJobflag = RunState::except;
		SQLFreeHandle(SQL_HANDLE_ENV, henv);
		return ;
	}

 	rc = SQLConnect(hdbc_dre, (SQLWCHAR*) CGlobalDataSaver::GetInstance()->m_sDbService.unicode(), SQL_NTS, 
  		(SQLWCHAR*) CGlobalDataSaver::GetInstance()->m_sDbUserName.unicode(), SQL_NTS, (SQLWCHAR*)CGlobalDataSaver::GetInstance()->m_sDbUserPass.unicode(), SQL_NTS);
	if (!SQL_SUCCEEDED(rc)) 
	{
		sErrorMsg = diagnostic(SQL_HANDLE_STMT, &hstmt_dre);
		m_sMsg = CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode("第[%1]进程建立数据库连接出错，错误码[%2][%3]，进程将退出")
			.arg(m_iProcessID)
			.arg(rc)
			.arg(CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode((char * )sErrorMsg));
		CGlobalDataSaver::GetInstance()->PrintMsg(m_sMsg);
		m_iJobflag = RunState::except;
		SQLFreeHandle(SQL_HANDLE_DBC, hdbc_dre);
		SQLFreeHandle(SQL_HANDLE_ENV, henv);
		return ;
	}

	rc = SQLSetConnectAttr(hdbc_dre, SQL_AUTOCOMMIT, (SQLPOINTER)SQL_AUTOCOMMIT_OFF, 0 );
	if (!SQL_SUCCEEDED(rc)) 
	{
		sErrorMsg = diagnostic(SQL_HANDLE_STMT, &hstmt_dre);
		m_sMsg = CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode("第[%1]进程SQLSetConnectAttr出错，错误码[%2][%3]，进程将退出")
			.arg(m_iProcessID)
			.arg(rc).arg(CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode((char * )sErrorMsg));;
		CGlobalDataSaver::GetInstance()->PrintMsg(m_sMsg);
		m_iJobflag = RunState::except;
		SQLDisconnect(hdbc_dre);
		SQLFreeHandle(SQL_HANDLE_DBC, hdbc_dre);
		SQLFreeHandle(SQL_HANDLE_ENV, henv);
		return ;
	}

	rc = SQLAllocHandle(SQL_HANDLE_STMT, hdbc_dre, &hstmt_dre); 
	if (!SQL_SUCCEEDED(rc)) 
	{
		sErrorMsg = diagnostic(SQL_HANDLE_STMT, &hstmt_dre);
		m_sMsg = CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode("第[%1]进程SQLAllocHandle出错，错误码[%2][%3]，进程将退出")
			.arg(m_iProcessID)
			.arg(rc)
			.arg(CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode((char * )sErrorMsg));;
		CGlobalDataSaver::GetInstance()->PrintMsg(m_sMsg);
		m_iJobflag = RunState::except;
		SQLDisconnect(hdbc_dre);
		SQLFreeHandle(SQL_HANDLE_DBC, hdbc_dre);
		SQLFreeHandle(SQL_HANDLE_ENV, henv);
		return ;
	}
	m_dtPick = QDateTime::currentDateTime();
	m_dtStartJob = m_dtPick;
	QString statement;
	if (RunState::insert == m_iJobflag )
	{
		statement = CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode("%1 INTO E_MIN_TABLE_P (vol_cur_id, meter_id, data_date, metering_time,PAP_E) VALUES "
			"(?, ?, ?, ?, ?)").arg(CGlobalDataSaver::GetInstance()->GetInsertString());

		crm_mnp_npdb_min *po = (crm_mnp_npdb_min *)malloc(CGlobalDataSaver::GetInstance()->m_iDCSL * sizeof(crm_mnp_npdb_min));
		SQLUSMALLINT *param_status = (SQLUSMALLINT *)malloc(CGlobalDataSaver::GetInstance()->m_iDCSL * sizeof(SQLUSMALLINT));
		SQLINTEGER params_processed = 0;

		rc = SQLSetStmtAttr(hstmt_dre, SQL_ATTR_PARAM_BIND_TYPE, (SQLPOINTER) sizeof(crm_mnp_npdb_min), 0);
		if (!SQL_SUCCEEDED(rc))
		{
			sErrorMsg = diagnostic(SQL_HANDLE_STMT, &hstmt_dre);
			CleanDBConnect(hstmt_dre, hdbc_dre, henv);
			free(po);
			free(param_status);
			m_sMsg = CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode("第[%1]进程 SQLSetStmtAttr 出错，错误码[%2][%3]，进程将退出")
				.arg(m_iProcessID)
				.arg(rc)
				.arg(CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode((char *)sErrorMsg));;
			CGlobalDataSaver::GetInstance()->PrintMsg(m_sMsg);
			m_iJobflag = RunState::except;
			return;
		}
		rc = SQLSetStmtAttr(hstmt_dre, SQL_ATTR_PARAMSET_SIZE, (SQLPOINTER)CGlobalDataSaver::GetInstance()->m_iDCSL, 0);
		if (!SQL_SUCCEEDED(rc))
		{
			sErrorMsg = diagnostic(SQL_HANDLE_STMT, &hstmt_dre);

			CleanDBConnect(hstmt_dre, hdbc_dre, henv);
			free(po);
			free(param_status);
			m_sMsg = CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode("第[%1]进程 SQLSetStmtAttr 出错，错误码[%2][%3]，进程将退出")
				.arg(m_iProcessID)
				.arg(rc)
				.arg(CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode((char *)sErrorMsg));;
			CGlobalDataSaver::GetInstance()->PrintMsg(m_sMsg);
			m_iJobflag = RunState::except;
			return;
		}
		rc = SQLSetStmtAttr(hstmt_dre, SQL_ATTR_PARAM_STATUS_PTR, param_status, 0);
		if (!SQL_SUCCEEDED(rc))
		{
			sErrorMsg = diagnostic(SQL_HANDLE_STMT, &hstmt_dre);
			CleanDBConnect(hstmt_dre, hdbc_dre, henv);
			free(po);
			free(param_status);
			m_sMsg = CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode("第[%1]进程 SQLSetStmtAttr 出错，错误码[%2][%3]，进程将退出")
				.arg(m_iProcessID)
				.arg(rc)
				.arg(CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode((char *)sErrorMsg));
			CGlobalDataSaver::GetInstance()->PrintMsg(m_sMsg);
			m_iJobflag = RunState::except;
			return;
		}
		rc = SQLSetStmtAttr(hstmt_dre, SQL_ATTR_PARAMS_PROCESSED_PTR, &params_processed, 0);
		if (!SQL_SUCCEEDED(rc))
		{
			sErrorMsg = diagnostic(SQL_HANDLE_STMT, &hstmt_dre);

			CleanDBConnect(hstmt_dre, hdbc_dre, henv);
			free(po);
			free(param_status);
			m_sMsg = CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode("第[%1]进程 SQLSetStmtAttr 出错，错误码[%2][%3]，进程将退出")
				.arg(m_iProcessID)
				.arg(rc)
				.arg(CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode((char *)sErrorMsg));
			CGlobalDataSaver::GetInstance()->PrintMsg(m_sMsg);
			m_iJobflag = RunState::except;
			return;
		}

		rc = SQLBindParameter(hstmt_dre, 1, SQL_PARAM_INPUT, SQL_C_DOUBLE, SQL_DOUBLE, po[0].len_vol_cur_id, 0, &po[0].vol_cur_id, sizeof(po[0].vol_cur_id), &po[0].len_vol_cur_id);
		rc = SQLBindParameter(hstmt_dre, 2, SQL_PARAM_INPUT, SQL_C_DOUBLE, SQL_DOUBLE, po[0].len_meter_id, 0, &po[0].meter_id, sizeof(po[0].meter_id), &po[0].len_meter_id);
		rc = SQLBindParameter(hstmt_dre, 3, SQL_PARAM_INPUT, SQL_C_TYPE_TIMESTAMP, SQL_TIMESTAMP, po[0].len_data_date, 0, &po[0].data_date, sizeof(po[0].data_date), &po[0].len_data_date);
		rc = SQLBindParameter(hstmt_dre, 4, SQL_PARAM_INPUT, SQL_C_TYPE_TIMESTAMP, SQL_TIMESTAMP, po[0].len_metering_time, 0, &po[0].metering_time, sizeof(po[0].metering_time), &po[0].len_metering_time);
		rc = SQLBindParameter(hstmt_dre, 5, SQL_PARAM_INPUT, SQL_C_DOUBLE, SQL_DOUBLE, po[0].len_V1, 0, &po[0].V1, sizeof(po[0].V1), &po[0].len_V1);


		m_sMsg = CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode("第[%1]进程数据库准备完毕，准备进入数据生成循环")
			.arg(m_iProcessID)
			.arg(CGlobalDataSaver::GetInstance()->m_sDbService);
		CGlobalDataSaver::GetInstance()->PrintMsg(m_sMsg);

		int iCurrDay;
		int iCurrMeter;
		QDate dtCurrent;

		m_iTickCount /*计数器，用来判定是否需要提交*/ = iCurrDay = iCurrMeter = 0;

		LONG64 iCommitCount;
		iCommitCount = 0;
		m_iCurrlLine = 0;


		if (m_iIDStart > m_iIDEnd)  //这个ID是记录ID ，不是电表ID
		{
			CleanDBConnect(hstmt_dre, hdbc_dre, henv);
			m_iJobflag = RunState::doneInsert;
			return;
		}
		rc = SQLPrepare(hstmt_dre, (SQLWCHAR*)statement.unicode(), SQL_NTS);
		if (!SQL_SUCCEEDED(rc))
		{
			sErrorMsg = diagnostic(SQL_HANDLE_STMT, &hstmt_dre);
			CleanDBConnect(hstmt_dre, hdbc_dre, henv);
			free(po);
			free(param_status);
			m_sMsg = CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode("第[%1]进程 SQLPrepare 出错，错误码[%2][%3]，进程将退出")
				.arg(m_iProcessID)
				.arg(rc)
				.arg(CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode((char *)sErrorMsg));
			CGlobalDataSaver::GetInstance()->PrintMsg(m_sMsg);
			m_iJobflag = RunState::except;
			return;
		}
		/* 外层按照日期递增循环 [2016-3-4 by zzg] */
		for (iCurrDay = 0;
			CGlobalDataSaver::GetInstance()->m_dtDataStart.addDays(iCurrDay) <= CGlobalDataSaver::GetInstance()->m_dtDataEnd;
			iCurrDay++)
		{
			dtCurrent = CGlobalDataSaver::GetInstance()->m_dtDataStart.addDays(iCurrDay);

			for (iCurrMeter = 0; iCurrMeter + m_iMeterIDStart <= m_iMeterIDEnd; iCurrMeter++)
			{
				m_iCurrlLine++;
				m_iIDCurrent = m_iCurrlLine + m_iIDStart - 1;
				//generating data
				po[m_iTickCount].metering_time.year = po[m_iTickCount].data_date.year = dtCurrent.year();
				po[m_iTickCount].metering_time.month = po[m_iTickCount].data_date.month = dtCurrent.month();
				po[m_iTickCount].metering_time.day = po[m_iTickCount].data_date.day = dtCurrent.day();

				po[m_iTickCount].vol_cur_id = m_iIDCurrent;
				po[m_iTickCount].meter_id = iCurrMeter + m_iMeterIDStart;
				po[m_iTickCount].V1 = (rand() % 41) + 1000;

				po[m_iTickCount].data_date.hour = 12;
				po[m_iTickCount].data_date.minute = 0;
				po[m_iTickCount].data_date.second = 0;
				po[m_iTickCount].data_date.fraction = 0;


				po[m_iTickCount].metering_time.hour = 12;
				po[m_iTickCount].metering_time.minute = 0;
				po[m_iTickCount].metering_time.second = 0;
				po[m_iTickCount].metering_time.fraction = 0;


				po[m_iTickCount].len_vol_cur_id = SQL_NTS;
				po[m_iTickCount].len_meter_id = SQL_NTS;

				po[m_iTickCount].len_V1 = SQL_NTS;

				po[m_iTickCount].len_data_date = sizeof(po[0].data_date);
				po[m_iTickCount].len_metering_time = sizeof(po[0].metering_time);

				m_iTickCount++;
				iCommitCount++;

				/* 如果达到提交量，或者所有数据已生成完毕，就提交 [2016-3-4 by zzg] */
				if (m_iTickCount >= CGlobalDataSaver::GetInstance()->m_iDCSL || m_iIDCurrent >= m_iIDEnd)
				{
					/* 提交一次 [2016-3-4 by zzg] */
					rc = 0;
					rc = SQLSetStmtAttr(hstmt_dre, SQL_ATTR_PARAMSET_SIZE, (SQLPOINTER)m_iTickCount, 0);
					if (rc != SQL_SUCCESS)
					{
						sErrorMsg = diagnostic(SQL_HANDLE_STMT, &hstmt_dre);
						CleanDBConnect(hstmt_dre, hdbc_dre, henv);
						free(po);
						free(param_status);
						m_sMsg = CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode("第[%1]进程SQLSetStmtAttr异常退出！已经写入[%2]行数据，剩余[%3]待写入[%4]")
							.arg(m_iProcessID)
							.arg(m_iCurrlLine)
							.arg(m_iIDEnd - m_iIDStart - m_iCurrlLine + 1)
							.arg(CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode((char *)sErrorMsg));
						CGlobalDataSaver::GetInstance()->PrintMsg(m_sMsg);
						m_iJobflag = RunState::except;
						return;
					}

					rc = SQLExecute(hstmt_dre);

					if (rc != SQL_SUCCESS)
					{
						sErrorMsg = diagnostic(SQL_HANDLE_STMT, &hstmt_dre);
						CleanDBConnect(hstmt_dre, hdbc_dre, henv);
						free(po);
						free(param_status);
						m_sMsg = CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode("第[%1]进程SQLExecute异常退出！已经写入[%2]行数据，剩余[%3]待写入[%4]")
							.arg(m_iProcessID)
							.arg(m_iCurrlLine)
							.arg(m_iIDEnd - m_iIDStart - m_iCurrlLine + 1)
							.arg(CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode((char *)sErrorMsg));
						CGlobalDataSaver::GetInstance()->PrintMsg(m_sMsg);
						m_iJobflag = RunState::except;
						return;
					}

					m_iTickCount = 0;
					/* 提交事物并发出提醒 [2016-3-4 by zzg] */
					rc = SQLEndTran(SQL_HANDLE_DBC, hdbc_dre, SQL_COMMIT);
					if (!SQL_SUCCEEDED(rc))
					{
						CleanDBConnect(hstmt_dre, hdbc_dre, henv);
						free(po);
						free(param_status);
						m_iJobflag = RunState::except;
						return;
					}

					m_iCommitedLine = m_iCurrlLine;
					m_iCommitedSize = (m_iCurrlLine * (sizeof(crm_mnp_npdb_min) + sizeof(SQLUSMALLINT)) / (1024 * 1024));
					m_sMsg = CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode("第[%1]进程已经写入[%2]行数据，剩余[%3]待写入")
						.arg(m_iProcessID)
						.arg(m_iCommitedLine)
						.arg(m_iIDEnd - m_iIDStart - m_iCurrlLine + 1);
					CGlobalDataSaver::GetInstance()->PrintMsg(m_sMsg);
					CGlobalDataSaver::GetInstance()->m_pTableOut->item(m_iProcessID - 1, 2)->setText(QString("%1").arg(m_iCurrlLine));
					rc = SQLPrepare(hstmt_dre, (SQLWCHAR*)statement.unicode(), SQL_NTS);
					iCommitCount = 0;
				}

				if (m_iIDCurrent >= m_iIDEnd)
					break;
			}
			if (m_iIDCurrent >= m_iIDEnd)
				break;
		}

		/* 提交事务并发出提醒 [2016-3-4 by zzg] */
		rc = SQLEndTran(SQL_HANDLE_DBC, hdbc_dre, SQL_COMMIT);
		if (!SQL_SUCCEEDED(rc))
		{
			CleanDBConnect(hstmt_dre, hdbc_dre, henv);
			free(po);
			free(param_status);
			m_iJobflag = RunState::except;
			return;
		}
		m_iCommitedLine = m_iCurrlLine;
		m_iCommitedSize = (LONG64)((m_iCurrlLine * (sizeof(crm_mnp_npdb_min) + sizeof(SQLUSMALLINT))) / (1024 * 1024));

		CleanDBConnect(hstmt_dre, hdbc_dre, henv);

		free(po);
		free(param_status);
	}

	if (RunState::insert == m_iJobflag)
	{
		m_iJobflag = RunState::doneInsert ;
		m_sMsg = CGlobalDataSaver::GetInstance()->m_pTextCode->toUnicode("第[%1]进程已经写入完毕，共写入[%2]行数据，用时[%3]秒")
			.arg(m_iProcessID)
			.arg(m_iCurrlLine)
			.arg(m_dtPick.secsTo(QDateTime::currentDateTime()));
	}
	CGlobalDataSaver::GetInstance()->PrintMsg(m_sMsg);
 
}


